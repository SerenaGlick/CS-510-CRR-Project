Serena Glick (sglick), Winter 2022, CS 510 Code Revision & Review

Critical Review Essay on the Original Oregon Trail Code from 1971

Video Presentation Link:
https://drive.google.com/file/d/1pYfi2FM59pUwfvfExu_CKdXV2W-vj0rJ/view?usp=sharing

Part I - Introduction

	The first computer game I ever played at school was in 1990.  I was in the 4th grade and it was “Oregon Trail II” on a blocky beige computer with a greenish screen, probably a Macintosh Classic.  We only had the one computer in the classroom so it was special experience whenever it was my turn to play.  Although I happened to be a child of two computer programmers and had been playing pixelated computer games since preschool (with that limited, vivid, magenta/cyan color scheme), this was the first time I played a video game that told a whole story, and it really made an impression on me.  
	For this particular project I chose to work with the original Oregon Trail Code (simply called ‘Oregon’ at the time) since it is a single file and thus simpler to tackle.  My practical experience with codebases was non-existent before this course, so I chose a piece of code that I felt was reasonable to work with.
	This codebase is actually not the original code, but a reconstruction written in 1971, later published in an issue of the journal "Creative Computing" in 1978.  There are three authors of this code reconstruction: Don Rawitsch, Bill Heinemann and Paul Dillenberger.  It is unclear why or how the original code was lost, but understandable that these things happened (especially before it was as simple as it is today to save, back-up, and distribute files).

Part 2 - Observations

	This particular codebase is written in BASIC, so after learning how to read developer documentation in this course, I decided to read up on the features of the BASIC language.  It was more difficult than expected to find the appropriate documentation online, probably because the language was popular in the 1970’s and fell out of use around the 1990’s, just when the internet (outside of academic institutions) was in a nascent state.  Nevertheless I persisted and found a page hosted by Dartmouth college (https://www.dartmouth.edu/basicfifty/commands.html). 
	BASIC is a very simple programming language (hence the name) that must be written sequentially and relies heavily on GOTO statements.  As such, it is marked with obligatory line numbers in the file which are constantly being referred to by various GOTO statements.  There is a related GOSUB command which goes to a subroutine, which can exited out of by using the statement RETURN.  This is interesting because I am used to all code being a part of a larger function (such as 'main') that needs to return, whereas with this BASIC code it seems returning is only necessary from subroutines.  At the end of the file there is a different command that is needed to end the program entirely, which is END.
	Other features of note are PRINT which prints to the screen, LET which can define, initializes, or update a variable, INPUT which takes in user input for a given variable, and REM which signifies a comment.  Interestingly, BASIC seems to support functions with a DEF command according to the documentation I read, though no functions were used in the Oregon code.  The only logic the code seems to use throughout are IF commands, in the format of IF (conditional) THEN (line number).  It also makes heavy se of random numbers as a branching condition.
	One of the topics we covered in this course is style, when we were introduced to the idea of a Linter.  Perhaps all programming languages were like this back in the day, but I find it interesting that everything is in all capital letters.  These days using all capital letters is akin to SHOUTING INFORMATION and is not considered good practice, except for constants. 
	Another aspect of style is how blocks of code are organized.  At first glance it appears the blocks of text are too large and need to be separated by more whitespace, but upon further review of the code, it appears they are already arranged appropriately as they contain elements that are related to each other.  Each thematic block of text is preceded by a comment that functions as a heading that looks **EXACTLY LIKE THIS** and at the end of the block there is a full line of whitespace.  It appears that it is simply the lack of functions and indentations are what make the blocks seem so enormous at times.  In other areas of the code they feel more appropriately proportioned, depending on the amount of details under that particular subheading.
	Next I would like to focus on comments.  I very much appreciate that each code block has a comment heading that tells what's happening, such as "***HUNTING***" or "***EATING***".  Other times these labels feel more obtuse, such as: "**BELLS IN LINE 2660**"  Reading the print statement for this section leads me to believe this is related to hunting, but it is a very strange label, especially since it refers to an actual element of the code.  That would make the comment very difficult to maintain if the line number were somehow changed in the code.
	Towards the end of the codebase there are two blocks of text labeled "**SHOOTING SUB-ROUTINE***" and "***ILLNESS SUB-ROUTINE***".  As mentioned earlier, there is a GOSUB command which can jump to a subroutine.  To me, subroutines look like functions that you go into for some task, and then exit out of when that task is completed.  As such I do not quite understand why there are only two subroutines in this entire program instead of most actions/events being classified as its own subroutine.  Later in this essay I will suggest a few further items that could be their own subroutines.
 	One feature that struck me when reading this code early on is that the variable names are incredibly short (1-2 characters: a letter and a number) and there is a key at the bottom of the code explaining what each variable means: "***IDENTIFICATION OF VARIABLES IN THE PROGRAM***".  Obviously this is not good form in the modern day; variables are supposed to be self-documenting.  Especially in light of our textbook's chapter on 'comments', code should be able to speak for itself as much as possible without the aid of comments, and I will suggest some alternative names to these variables in the next section.  
	Reading through the code and tracing through the logic, I found a strange example of error handling. Early on the code asks the user to describe how good of a shot they are with a rifle, stored into variable D9, with choices between 1-5.  After the user inputs their number, there is a line which states "IF D9>5 THEN 790" and at line 790 it says "LET D9=0."  I'm not sure why an out of bounds value defaults to 0 when 0 in not an option in the first place; perhaps it would make sense to default to 5 instead (which is the worst value amongst the choices given: "shaky knees").  It also doesn't make sense to me why the authors chose to check only values above 5, but not below 1.  Additionally, I believe there would be an error message nowadays if a user inputted a value out of bounds, and would likely be prompted to try again or else have the program terminate.  Simply defaulting to a value that was not a valid choice to begin with seems strange logic to me.
	Another logic item I am confused about is setting the date you begin one's journey.  There is a variable D3 that is labeled as the "turn number for setting date".  Initially it is set to 0: "LET D3=0".  Then the next occurrence of this variable says "LET D3=D3+1".  Okay, so now D3 should equal 1.  After printing "Monday" it then goes on to have a logic check: IF D3>10 THEN 1300.  How on earth could it be anything other than 1 at this point?  Similarly, if D3 fails this check (since I'm assuming it equals 1), the next line has a goto with several line numbers: "ON D3 GO TO 1310, 1330, 1350, 1370, 1390, 1410, 1430, 1450, 1470, 1490".  I thought a GOTO had to point to a single line number, so I don't know how it is differentiated between the two of these.  Trying to google documentation on multiple lines being listed after a goto reveals no results.  Perhaps it functions like a primitive switch statement, where the GOTO line numbers represent indices of 0, 1, 2, etc and are selected on that basis.  Unfortunately I cannot find any documentation regarding the ON syntax does so I have no way of confirming or denying my hypothesis.  

Part 3 - Suggestions
	Now that I have introduced some basics about this code, such as the history of the game, some basic BASIC syntax, and some observations I had while reading through the code, I would like to begin offering some suggestions on how this code could be improved upon.
	As mentioned earlier, one of the items that jumped out at me upon first glance at this codebase was the fact that variable names were short, nearly meaningless, and needed a table to explain what they mean at the end of the code.  I do not know if it was common practice in the day to use short variable names, or if the BASIC language had character limitations for variables; in any case it iss certainly an outdated idea for anything other than a loop counter variable (ie: let i = 0) or basic math expressions (ie: add (x,y)) to use short variable names.  
	Below is a table of the actual variables in the program, followed by my suggestions if I were to update them to fully descriptive names.  Since most of these variables are numbers, please assume the variable would be of type number (if we were using Typescript) and if it ought to be a different type, I specify it after a colon : also TypeScript Style.  It is actually an interesting point to note that the variable types were not specified in this program, which I had not realized before this exercise.  I imagine early programming languages did not have the concept of type checking, and that feature was added later on.  

REM ***IDENTIFICATION OF VARIABLES IN THE PROGRAM***
6480 REM A = AMOUNT SPENT ON ANIMALS -> amt_spent_animals
6490 REM B = AMOUNT SPENT ON AMMUNITION -> amt_spent_ammo
6500 REM B1 = ACTUAL RESPONSE TIME FOR INPUTTING "BANG"->bang_response_time
6510 REM B3 = CLOCK TIME AT START OF INPUTTING "BANG" ->bang_clock_start_time
6520 REM C = AMOUNT SPENT ON CLOTHING -> amt_spent_clothes
6530 REM C1 = FLAG FOR INSUFFICIENT CLOTHING IN COLD WEATHER ->warm_clothes : boolean
6540 REM C$ = YES/NO RESPONSE TO QUESTIONS -> user_response : string (or character)
6550 REM D1 = COUNTER IN GENERATING EVENTS -> random_event_counter
6560 REM D3 = TURN NUMBER FOR SETTING DATE -> initial_date
6570 REM D4 = CURRENT DATE -> current_date

6580 REM D9 = CHOICE OF SHOOTING EXPERTISE LEVEL -> shooting_expertise : enum {ace, good, fair, low, shaky}
(Original shooting options ford deciding enum types: (1) ACE MARKSMAN,  (2) GOOD SHOT,  (3) FAIR TO MIDDLIN'"
730 PRINT "         (4) NEED MORE PRACTICE,  (5) SHAKY KNEES")

6590 REM E = CHOICE OF EATING -> eating_choice : enum {poor, moderate, well}
(Original: "DO YOU WANT TO EAT (1) POORLY   (2) MODERATELY  OR (3) WELL";)

6600 REM F = AMOUNT SPENT ON FOOD -> amt_spent_food
6610 REM F1 = FLAG FOR CLEARING SOUTH PASS -> clear_south_pass : boolean
6620 REM F2 = FLAG FOR CLEARING BLUE MOUNTAINS -> clear_blue_mountains : boolean
6630 REM F9 = FRACTION OF 2 WEEKS TRAVELED ON FINAL TURN -> final_turn_traveled
6640 REM K8 = FLAG FOR INJURY -> injury : boolean
6650 REM L1 = FLAG FOR BLIZZARD -> blizzard : boolean
6660 REM M = TOTAL MILEAGE WHOLE TRIP -> total_miles_traveled
6670 REM M1 = AMOUNT SPENT ON MISCELLANEOUS SUPPLIES ->amt_spent_misc
6680 REM M2 = TOTAL MILEAGE UP THROUGH PREVIOUS TURN ->current_miles_traveled
6690 REM M9 = FLAG FOR CLEARING SOUTH PASS IN SETTING MILEAGE -> clear_south_pass_speedy : boolean
6700 REM P = AMOUNT SPENT ON ITEMS AT FORT -> amt_spent_at_fort
6710 REM R1 = RANDOM NUMBER IN CHOOSING EVENTS -> rand_num_for_event
6720 REM S4 = FLAG FOR ILLNESS -> illness : boolean
6730 REM S5 = ""HOSTILITY OF RIDERS"" FACTOR -> riders_hostile : boolean
6740 REM S6 = SHOOTING WORD SELECTOR -> shooting_word_choice (notes: will result in 1-4, to go with variable below)
6750 REM S$ = VARIATIONS OF SHOOTING WORD -> shooting_word : enum {bang, blam, pow, wham}
6760 REM T = CASH LEFT OVER AFTER INITIAL PURCHASES -> cash_for_trip
6770 REM T1 = CHOICE OF TACTICS WHEN ATTACKED -> attack_tactics : enum {run, attack, continue, circle}
6780 REM X = CHOICE OF ACTION FOR EACH TURN -> hunt_continue_option : boolean
6790 REM X1 = FLAG FOR FORT OPTION -> stop_at_fort : boolean
	
	If I had more time available, I would want to consider whether some of these stand-alone variables could be reconfigured into more of a cohesive structure, such as classes.  For example, there could be a whole class around spending money, and the associated methods relating to what is being bought, when, and how (such as at the start of the game vs. later when stopping at a fort).  In fact, it would probably improve the code significantly to be organized into a class structure, vs. simply using blocks of code, and I will reflect on this more in the following paragraph.
	During the time of BASIC classes were still unavailable, as Object Oriented Programming is a concept developed much later.  Without the aid of classes, the authors of this code seemed to do their best to organize as much as possible into logically cohesive blocks of text with proper headings to define their purpose.  However one point that I feel the authors could have improved upon is making more of the code blocks into subroutines.  Perhaps this is only because I am looking at the code from an Object Oriented perspective that it seems to be lacking, and perhaps what the authors was doing at the time with 'subroutines' (which appear to be a primitive version of a function, as far as I can tell) was already advanced programming practice.  Even so, only two concepts in the game are encoded as subroutines: hunting and illness.  However, I noticed another repetitive event which is "***STOPPING AT FORT***" that could likely be is own subroutine as well.  Ironically, as I read through the code in that particular block, there is already use of a GOSUB command: "GOSUB 2330" which leads to another line in that same block of code, further down, which relates to whether or not someone has enough money to buy a particular item.  Therefore, perhaps it is my fault for viewing a subroutine as a function or other method of encapsulating, when perhaps the authors are looking at it simply as a logical element akin to 'while' or 'if/then'.  
	Whatever the original purpose of the designation 'subroutine', there are definitely elements of the code that would benefit from being their own functions in a modern day programming language. One obvious example would be the code involved in the block labeled "***RIDERS ATTACK***".  Additionally, we have the block of text "***SELECTION OF EVENTS***" which from the title we can infer has multiple kinds of things happening inside it, and thus would need to be further broken down into its logical components.  One of those components might be a function that is a random event generator, since in this code there is often a random number used to decide which event happens ("LET R1=100*RND()").  After that there could be a switch statement which could trigger the corresponding function associated with that random number, or possibly the different events could be classified as enums instead of numbers.
	One final topic I wish to touch upon, that was the most salient to me when choosing this code base, was the ample (though necessary at the time) usage of GOTO statements.  I find this relic of modern programming fascinating, and wanted to explore it a bit further.  However, with the time and energy I have available to me, I must be forthright and say I was not able to explore this particular aspect of the code as much as I would have liked.  It would have been interesting to see how some of the GOTOs would be organized logically today; I imagine they would use quite similar logic present in the code already such as if/then statements. Here is one particular example that does not use a GOTO but does use an if/then statement:
4880 IF RND()<.8 THEN 4970
4890 PRINT "YOU MADE IT SAFELY THROUGH SOUTH PASS--NO SNOW"
...
4970 PRINT "BLIZZARD IN MOUNTAIN PASS--TIME AND SUPPLIES LOST"
	Of course, there are other logical syntax available in modern languages that were not available in BASIC, such as loops and switch statements that may have been helpful.  The authors were indeed very industrious in using what resources they had available to them, such as making ample use of the random function (RND()) which appears to be built in to the language, since there is no declaration of it anywhere in the code.  It was often used, as mentioned above, to decide whether or not an event happens, sometimes with very detailed steps, such as "LET B=B-10-RND()*4".
	In doing one final read through of this codebase, I found that if one successfully completes this game, they are greeted with the message "YOU FINALLY ARRIVED AT OREGON CITY".  As a non-native Oregonian (though a native West-Coaster) I did not know the Oregon City was the original capitol of Oregon for four years before switching to Salem, the current capital, in 1852.  I also realize at this point in time (the year 2022) that idealizing the pioneers who traveled west in search of a better life is actually a part of a greater scheme of colonization and white supremacy that had a terrible, traumatic, and tragic impact on native American people and on the land that they stewarded for so many thousands of years before white people came through and greedily destroyed much of it.  I am sorry to say that my family lineage may even be culpable in such matters, as we were not always native Californians, but did migrate from the East at some point if I am remembering family history correctly.  Here's hoping that my family now, and the generations that come after us, will do better and be better to all our fellow human beings.
	Thank you for an interesting (if difficult) semester.  Take good care of yourselves Katie & Katherine!!!

Link to codebase:
https://github.com/LiquidFox1776/oregon-trail-1978-basic/blob/master/oregon-trail-1978.bas